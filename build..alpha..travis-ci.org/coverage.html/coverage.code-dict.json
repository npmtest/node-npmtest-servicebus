{"/home/travis/build/npmtest/node-npmtest-servicebus/test.js":"/* istanbul instrument in package npmtest_servicebus */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-servicebus/lib.npmtest_servicebus.js":"/* istanbul instrument in package npmtest_servicebus */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_servicebus = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_servicebus = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-servicebus/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-servicebus && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_servicebus */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_servicebus\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_servicebus.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_servicebus.rollup.js'] =\n            local.assetsDict['/assets.npmtest_servicebus.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_servicebus.__dirname +\n                    '/lib.npmtest_servicebus.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-servicebus/node_modules/servicebus/index.js":"module.exports = require('./bus');","/home/travis/build/npmtest/node-npmtest-servicebus/node_modules/servicebus/bus/index.js":"var rabbitmq = require('./rabbitmq/bus');\n\nmodule.exports.bus = function bus (options, implOpts) {\n  return new rabbitmq.Bus(options, implOpts);\n};\n\nvar namedBuses = {};\n\nmodule.exports.namedBus = function namedBus(name, options, implOpts) {\n  var bus = namedBuses[name];\n  if ( ! bus) {\n    bus = namedBuses[name] = new rabbitmq.Bus(options, implOpts);\n  }\n  return bus;\n};","/home/travis/build/npmtest/node-npmtest-servicebus/node_modules/servicebus/bus/rabbitmq/bus.js":"var amqp = require('amqplib'),\n    Bus = require('../bus'),\n    Correlator = require('./correlator'),\n    log = require('debug')('servicebus'),\n    events = require('events'),\n    extend = require('extend'),\n    json = require('../formatters/json'),\n    newId = require('node-uuid'),\n    PubSubQueue = require('./pubsubqueue'),\n    querystring = require('querystring'),\n    Queue = require('./queue'),\n    util = require('util');\n\nfunction RabbitMQBus (options, implOpts) {\n  var self = this;\n\n  options = options || {};\n  options.url = options.url || process.env.RABBITMQ_URL || 'amqp://localhost';\n  options.vhost = options.vhost || process.env.RABBITMQ_VHOST;\n  options.exchangeName = options.exchangeName || 'amq.topic';\n  options.exchangeOptions = options.exchangeOptions || {};\n\n  this.assertQueuesOnFirstSend = (options.assertQueuesOnFirstSend === undefined) ? true : options.assertQueuesOnFirstSend;\n  this.channels = [];\n  this.correlator = options.correlator || new Correlator(options);\n  this.delayOnStartup = options.delayOnStartup || 10;\n  this.exchangeName = options.exchangeName;\n  this.formatter = json;\n  this.initialized = false;\n  this.log = options.log || log;\n  this.prefetch = options.prefetch;\n  this.pubsubqueues = {};\n  this.queues = {};\n  this.queuesFile = options.queuesFile;\n\n  var vhost = options.vhost && util.format('/%s', querystring.escape(options.vhost));\n  var url = vhost ? util.format('%s%s', options.url, vhost) : options.url;\n\n  self.log('connecting to rabbitmq on %s', url);\n\n  amqp.connect(url, implOpts).then(function (conn) {\n\n    self.connection = conn;\n\n    function channelError (err) {\n      self.log('channel error with connection %s error: %s', options.url, err.toString());\n      self.emit('error', err);\n    }\n\n    conn.on('close', self.emit.bind(self, 'connection.close'));\n    conn.on('error', self.emit.bind(self, 'connection.error'));\n\n    function done () {\n      if (self.channels.length === (options.enableConfirms ? 3 : 2)) {\n        self.initialized = true;\n        self.log('connected to rabbitmq on %s', url);\n        self.emit('ready');\n      }\n    }\n\n    self.connection.createChannel().then(function (channel) {\n      channel.on('error', channelError);\n      channel.on('close', self.emit.bind(self, 'channel.close'));\n      self.sendChannel = channel;\n      if (options.prefetch) {\n        self.sendChannel.prefetch(options.prefetch);\n      }\n      self.channels.push(channel);\n      done();\n    });\n\n    self.connection.createChannel().then(function (channel) {\n      channel.on('error', channelError);\n      channel.on('close', self.emit.bind(self, 'channel.close'));\n      self.listenChannel = channel;\n      if (options.prefetch) {\n        self.listenChannel.prefetch(options.prefetch);\n      }\n      self.channels.push(channel);\n      done();\n    });\n\n    if (options.enableConfirms) {\n      self.connection.createConfirmChannel().then(function (channel) {\n        channel.on('error', channelError);\n        channel.on('close', self.emit.bind(self, 'channel.close'));\n        self.confirmChannel = channel;\n        if (options.prefetch) {\n          self.confirmChannel.prefetch(options.prefetch);\n        }\n        self.channels.push(channel);\n        done();\n      });\n    }\n\n  }).catch(function (err) {\n    self.log('error connecting to rabbitmq: %s', err);\n    self.emit('error', err);\n  });\n\n  Bus.call(this);\n}\n\nutil.inherits(RabbitMQBus, Bus);\n\nRabbitMQBus.prototype.listen = function listen (queueName, options, callback) {\n\n  var self = this;\n\n  this.log('listen on queue %j', queueName);\n\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  if ( ! this.initialized) {\n    return this.on('ready', listen.bind(this, queueName, options, callback));\n  }\n\n  this.setOptions(queueName, options);\n\n  if (this.queues[options.queueName] === undefined) {\n    this.log('creating queue %s', options.queueName);\n    var queue = new Queue(options);\n    queue.on('listening', function () {\n      self.emit('listening', queue);\n    });\n    this.queues[options.queueName] = queue;\n  }\n\n  this.queues[options.queueName].listen(callback, options);\n\n};\n\nRabbitMQBus.prototype.unlisten = function unlisten (queueName, options) {\n  if (this.queues[queueName] === undefined) {\n    throw new Error(util.format('no queue currently listening at %s', queueName));\n  } else {\n    var result = this.queues[queueName].unlisten(options);\n    delete this.queues[queueName];\n    return result;\n  }\n};\n\nRabbitMQBus.prototype.destroyListener = function removeListener (queueName, options) {\n  options = options || {};\n  if ( ! options.force && this.queues[queueName] === undefined) {\n    throw new Error(util.format('no queue currently listening at %s', queueName));\n  } else {\n    var q = this.queues[queueName];\n    if (! q && options.force) {\n      var em = new events.EventEmitter();\n      this.listenChannel.deleteQueue(queueName, { ifEmpty: false })\n        .then(function (ok) {\n          em.emit('success');\n        });\n      return em;\n    }\n    delete this.queues[queueName];\n    return q.destroy();\n  }\n};\n\nRabbitMQBus.prototype.setOptions = function (queueName, options) {\n  if (typeof queueName === 'object') {\n    options.queueName = queueName.queueName;\n    options.routingKey = queueName.routingKey;\n    queueName = queueName.queueName;\n  } else {\n    options.queueName = queueName;\n  }\n\n  extend(options, {\n    assertQueue: this.assertQueuesOnFirstSend,\n    bus: this,\n    confirmChannel: this.confirmChannel,\n    correlator: this.correlator,\n    formatter: this.formatter,\n    listenChannel: this.listenChannel,\n    log: this.log,\n    queuesFile: this.queuesFile,\n    sendChannel: this.sendChannel\n  });\n};\n\nRabbitMQBus.prototype.send = function send (queueName, message, options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  if ( ! this.initialized) {\n    return this.on('ready', send.bind(this, queueName, message, options, cb));\n  }\n\n  if (cb && ! this.confirmChannel) return cb(new Error('callbacks only supported when created with bus({ enableConfirms:true })'))\n\n  this.setOptions(queueName, options);\n\n  var key = this.confirmChannel && cb ? options.queueName + '.confirm' : options.queueName;\n\n  if (this.queues[key] === undefined) {\n    this.queues[key] = new Queue(options);\n  }\n\n  this.handleOutgoing(options.queueName, message, options, function (queueName, message, options) {\n    this.queues[key].send(message, options, cb);\n  }.bind(this));\n\n};\n\nRabbitMQBus.prototype.subscribe = function subscribe (queueName, options, callback) {\n  var self = this;\n\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  this.log('subscribe on queue %j', queueName);\n\n  var handle = null;\n  function _unsubscribe (options) {\n    handle.unsubscribe(options);\n  }\n\n  if ( ! this.initialized) {\n    return this.on('ready', subscribe.bind(this, queueName, options, callback));\n  }\n\n  this.setOptions(queueName, options);\n\n  if (this.pubsubqueues[options.queueName] === undefined) {\n    this.log('creating pusubqueue %s', options.queueName);\n    var pubSubQueue = new PubSubQueue(options);\n    pubSubQueue.on('subscribed', function () {\n      self.emit('subscribed', pubSubQueue);\n    });\n    this.pubsubqueues[options.queueName] = pubSubQueue;\n  }\n\n  handle = this.pubsubqueues[options.queueName].subscribe(options, callback);\n\n  return {\n    unsubscribe: _unsubscribe\n  };\n\n};\n\nRabbitMQBus.prototype.publish = function publish (queueName, message, options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  if ( ! this.initialized) {\n    return this.on('ready', publish.bind(this, queueName, message, options, cb));\n  }\n\n  if (cb && ! this.confirmChannel) return cb(new Error('callbacks only supported when created with bus({ enableConfirms:true })'))\n\n  this.setOptions(queueName, options);\n\n  var key = this.confirmChannel && cb  ? options.queueName + '.confirm' : options.queueName;\n\n  if (this.pubsubqueues[key] === undefined) {\n    this.pubsubqueues[key] = new PubSubQueue(options);\n  }\n\n  this.handleOutgoing(options.queueName, message, options, function (queueName, message, options) {\n    this.pubsubqueues[key].publish(message, options, cb);\n  }.bind(this));\n\n};\n\nRabbitMQBus.prototype.close = function close () {\n\n  this.log('closing channels and connection');\n  this.channels.forEach(function (channel) {\n    channel.close();\n  });\n  this.connection.close();\n\n};\n\nmodule.exports.Bus = RabbitMQBus;\n","/home/travis/build/npmtest/node-npmtest-servicebus/node_modules/servicebus/bus/bus.js":"var EventEmitter = require('events').EventEmitter;\nvar readableId = require('readable-id');\nvar util = require('util');\n\nfunction Bus () {\n  this.incomingMiddleware = [];\n  this.outgoingMiddleware = [];\n  EventEmitter.call(this);\n  this.setMaxListeners(Infinity);\n}\n\nutil.inherits(Bus, EventEmitter);\n\nBus.prototype.use = function (middleware) {\n  if (middleware.handleIncoming) this.incomingMiddleware.push(middleware.handleIncoming);\n  if (middleware.handleOutgoing) this.outgoingMiddleware.push(middleware.handleOutgoing);\n  return this;\n};\n\nBus.prototype.handleIncoming = function (/* channel, message, options, callback */) {\n  var index = this.incomingMiddleware.length - 1;\n  var self = this;\n\n  var args = Array.prototype.slice.call(arguments);\n\n  var callback = args.pop();\n\n  function next (err) {\n    if (err) return callback(err);\n\n    var layer;\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    layer = self.incomingMiddleware[index];\n\n    index = index - 1;\n\n    if ( undefined === layer) {\n      return callback.apply(self, args);\n    } else {\n      args.push(next);\n      return layer.apply(self, args);\n    }\n  }\n\n  args.unshift(null);\n\n  return next.apply(this, args);\n};\n\nBus.prototype.handleOutgoing = function (queueName, message, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  var index = 0;\n  var self = this;\n\n\n  function next (err) {\n    if (err) return callback(err);\n\n    var layer;\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    layer = self.outgoingMiddleware[index];\n\n    index++;\n\n    if ( undefined === layer) {\n      return callback.apply(self, args);\n    } else  {\n      args.push(next);\n      return layer.apply(self, args);\n    }\n  }\n\n  return next(null, queueName, message, options);\n};\n\nBus.prototype.correlate = require('./middleware/correlate');\nBus.prototype.messageDomain = require('./middleware/messageDomain');\nBus.prototype.logger = require('./middleware/logger');\nBus.prototype.package = require('./middleware/package');\nBus.prototype.retry = require('./middleware/retry');\n\nBus.prototype.createCorrelationId = Bus.prototype.correlationId = function (forceNew) {\n  if (process.domain && process.domain.correlationId && ! forceNew) {\n    return process.domain.correlationId;\n  }\n  return readableId();\n};\n\nmodule.exports = Bus;\n","/home/travis/build/npmtest/node-npmtest-servicebus/node_modules/servicebus/bus/middleware/correlate.js":"var newId = require('node-uuid');\n\nfunction addCorrelationId (queueName, message, options, next) {\n  if (typeof options === 'function') {\n    next = options;\n    options = null;\n  }\n\n  if ( ! message.cid) {\n    message.cid = newId();\n  }\n\n  next(null, queueName, message, options);\n}\n\nmodule.exports = function () {\n  return {\n    handleOutgoing: addCorrelationId\n  };\n}","/home/travis/build/npmtest/node-npmtest-servicebus/node_modules/servicebus/bus/middleware/messageDomain.js":"var domain = require('domain');\n\nmodule.exports = function messageDomain (opts) {\n\n  opts = opts || {};\n\n  return {\n\n    handleIncoming: function json (channel, message, options, next) {\n      \n      var d = domain.create();\n      \n      if (opts.onError) {\n        d.on('error', function (err) {\n          if (opts.onError) {\n            opts.onError(err, message, channel, d);\n          } else {\n            throw err;\n          }\n        });\n      }\n\n      d.run(function() {\n\n        if (message.properties.correlationId) {\n          d.correlationId = message.properties.correlationId;\n        }\n\n        next.bind(this, null, channel, message, options)();\n        \n      });\n\n    },\n\n  };\n};","/home/travis/build/npmtest/node-npmtest-servicebus/node_modules/servicebus/bus/middleware/logger.js":"var debug = require('debug'),\n    util = require('util');\n\nmodule.exports = function (options) {\n  options = options || {};\n  label = options.label || 'servicebus';\n  var log = options.log || debug(label);\n  fnIncoming = options.fnIncoming || function (channel, message, options, next) {\n    log(util.format('received %j via routingKey %s', message.content, message.fields.routingKey));\n  };\n  fnOutgoing = options.fnOutgoing || function (message, queueName) {\n    log(util.format('sending %j to %s', message, queueName));\n  };\n\n  function logIncoming (channel, message, options, next) {\n    fnIncoming(channel, message, options);\n    var args = Array.prototype.slice.call(arguments);\n    var next = args.pop();\n    args.unshift(null);\n    next.apply(this, args);\n  }\n\n  function logOutgoing (queueName, message, options, next) {\n    if (typeof options === 'function') {\n      next = options;\n      options = null;\n    }\n\n    fnOutgoing(message, queueName);\n    next(null, queueName, message, options);\n  }\n\n  return {\n    handleIncoming: logIncoming,\n    handleOutgoing: logOutgoing\n  };\n}","/home/travis/build/npmtest/node-npmtest-servicebus/node_modules/servicebus/bus/middleware/package.js":"function packageMessage (queueName, message, options, next) {\n  if (typeof options === 'function') {\n    next = options;\n    options = null;\n  }\n\n  var newMessage = {\n      data: message\n    , datetime: message.datetime || new Date().toUTCString()\n    , type: message.type || queueName\n  };\n\n  next(null, queueName, newMessage, options);\n\n}\n\nfunction handleIncoming (channel, message, options, next) {\n  message.content.type = message.properties.type || message.content.type;\n  next(null, channel, message, options);\n}\n\nmodule.exports = function () {\n  return {\n    handleOutgoing: packageMessage,\n    handleIncoming: handleIncoming\n  };\n};","/home/travis/build/npmtest/node-npmtest-servicebus/node_modules/servicebus/bus/middleware/retry.js":"module.exports = function (options) {\n  throw new Error('bus.retry() middleware is deprecated. please use https://github.com/mateodelnorte/servicebus-retry instead')\n};\n","/home/travis/build/npmtest/node-npmtest-servicebus/node_modules/servicebus/bus/rabbitmq/correlator.js":"var cluster = require('cluster');\nvar events = require('events'),\n    fs = require('fs'),\n    newId = require('node-uuid'),\n    path = require('path'),\n    util = require('util');\nvar warn = require('debug')('servicebus:warn');\n\nfunction Correlator (options) {\n  this.initialized = false;\n  this.queues = {};\n\n  // note: if you want to cluster servicebus, provide a 'queuesfile' option param when calling .bus(options). you'll likely do a mod of the cluster.worker.id in your cluster.js file when you call fork();\n  if (cluster.isWorker && options.queuesFile === undefined) warn('Warning, to use subscriptions in a clustered app, you should specify a queuesFile option when calling .bus(options). You may want to provide something like util.format(\\'.queues.worker.%s\\', (cluster.worker.id % cluster.workers.length)).');\n\n  this.filename =\n    (options && options.queuesFile) ? path.join(process.cwd(), options.queuesFile)\n      : (cluster.isWorker) ? path.join(process.cwd(), util.format('.queues.worker.%s', cluster.worker.id))\n        :path.join(process.cwd(), '.queues');\n\n  fs.readFile(this.filename, function (err, buf) {\n    if (err) {\n      this.queues = {};\n      this.initialized = true;\n      this.emit('ready');\n      return;\n    }\n    try {\n      this.queues = JSON.parse(buf.toString());\n    } catch (error) {\n      this.queues = {};\n    } \n    this.initialized = true;\n    this.emit('ready');\n  }.bind(this));\n\n  events.EventEmitter.call(this);\n}\n\nutil.inherits(Correlator, events.EventEmitter);\n\nCorrelator.prototype.queueName = function queueName (options, callback) {\n\n  if ( ! this.initialized) {\n    return this.on('ready', queueName.bind(this, options, callback));\n  }\n\n  var result;\n\n  if (this.queues.hasOwnProperty(options.queueName)) {\n    result = this.queues[options.queueName];\n  } else if (options.routingKey) {\n    result = options.queueName;\n  } else {\n    result = util.format('%s.%s', options.queueName, newId());\n    this.queues[options.queueName] = result;\n  }\n\n  this.persistQueueFile(function (err) {\n    if (err) return callback(err);\n    callback(null, result);\n  });\n\n};\n\nCorrelator.prototype.persistQueueFile = function (callback) {\n  var contents = JSON.stringify(this.queues);\n  fs.writeFile(this.filename, contents, callback);\n};\n\nmodule.exports = Correlator;\n","/home/travis/build/npmtest/node-npmtest-servicebus/node_modules/servicebus/bus/formatters/json.js":"module.exports.deserialize = function deserialize (content) {\n  \n  try {\n    content = JSON.parse(content);\n  } catch (err) {\n    throw err;\n  }\n\n  return content;\n\n};\n\nmodule.exports.serialize = function serialize (content) { \n  \n  try {\n    content = JSON.stringify(content);\n  } catch (err) {\n    throw err;\n  }\n\n  return content;\n\n};","/home/travis/build/npmtest/node-npmtest-servicebus/node_modules/servicebus/bus/rabbitmq/pubsubqueue.js":"var events = require('events');\nvar extend = require('extend');\nvar newId = require('node-uuid').v4;\nvar util = require('util');\n\nfunction PubSubQueue (options) {\n  options = options || {};\n  var exchangeOptions = options.exchangeOptions || {};\n  var queueOptions = options.queueOptions || {};\n\n  extend(queueOptions, {\n    autoDelete: options.autoDelete || ! (options.ack || options.acknowledge),\n    contentType: options.contentType || 'application/json',\n    durable: Boolean(options.ack || options.acknowledge),\n    exclusive: options.exclusive || false,\n    persistent: Boolean(options.ack || options.acknowledge || options.persistent)\n  });\n\n  extend(exchangeOptions, {\n    type: exchangeOptions.type || 'topic',\n    durable: exchangeOptions.durable === false ? false : true,\n    autoDelete: exchangeOptions.autoDelete || false\n  });\n\n  this.ack = (options.ack || options.acknowledge);\n  this.bus = options.bus;\n  this.confirmChannel = options.confirmChannel;\n  this.correlator = options.correlator;\n  this.errorQueueName = options.queueName + '.error';\n  this.exchangeName = options.exchangeName || this.bus.exchangeName || 'amq.topic';\n  this.exchangeOptions = exchangeOptions;\n  this.formatter = options.formatter;\n  this.initialized = false;\n  this.listening = false;\n  this.listenChannel = options.listenChannel;\n  this.log = options.log;\n  this.maxRetries = options.maxRetries || 3;\n  this.queueName = options.queueName;\n  this.queueOptions = queueOptions;\n  this.rejected = {};\n  this.routingKey = options.routingKey;\n  this.sendChannel = options.sendChannel;\n\n  this.log('asserting exchange %s', this.exchangeName);\n  this.sendChannel.assertExchange(this.exchangeName, this.exchangeOptions.type || 'topic', this.exchangeOptions);\n\n  if (this.confirmChannel) {\n    this.confirmChannel.assertExchange(this.exchangeName, this.exchangeOptions.type || 'topic', this.exchangeOptions);\n  }\n\n  events.EventEmitter.call(this);\n\n  this.setMaxListeners(Infinity);\n}\n\nutil.inherits(PubSubQueue, events.EventEmitter);\n\nPubSubQueue.prototype.publish = function publish (event, options, cb) {\n  options = options || {};\n  var self = this;\n\n  options.contentType = options.contentType || this.contentType;\n\n  var channel = cb ? self.confirmChannel : self.sendChannel;\n\n  channel.publish(self.exchangeName, self.routingKey || self.queueName, new Buffer(options.formatter.serialize(event)), options, cb);\n\n};\n\nPubSubQueue.prototype.subscribe = function subscribe (options, callback) {\n  var self = this;\n  var subscribed = false;\n  var subscription = null;\n\n  this.log('subscribing to queue %j with routingKey %j', this.queueName, this.routingKey);\n\n  function _unsubscribe (cb) {\n    if (subscribed) {\n      // should we prevent multiple cancel calls?\n      self.listenChannel\n        .cancel(subscription.consumerTag)\n        .then(function () {\n          self.emit('unlistened');\n          if (cb) {\n            cb();\n          }\n        });\n    } else {\n      self.on('subscribed', _unsubscribe.bind(this, cb));\n    }\n  }\n\n  function _subscribe (uniqueName) {\n    self.listenChannel.consume(uniqueName, function (message) {\n      /*\n          Note from http://www.squaremobius.net/amqp.node/doc/channel_api.html\n          & http://www.rabbitmq.com/consumer-cancel.html:\n\n          If the consumer is cancelled by RabbitMQ, the message callback will be invoked with null.\n        */\n      if (message === null) {\n        return;\n      }\n      // todo: map contentType to default formatters\n      message.content = options.formatter.deserialize(message.content);\n      options.queueType = 'pubsubqueue';\n      self.bus.handleIncoming(self.listenChannel, message, options, function (channel, message, options) {\n        // amqplib intercepts errors and closes connections before bubbling up\n        // to domain error handlers when they occur non-asynchronously within\n        // callback. Therefore, if there is a process domain, we try-catch to\n        // redirect the error, assuming the domain creator's intentions.\n        try {\n          callback(message.content, message);\n        } catch (err) {\n          if (process.domain && process.domain.listeners('error')) {\n            process.domain.emit('error', err);\n          } else {\n            self.emit('error', err);\n          }\n        }\n      });\n    }, { noAck: ! self.ack })\n      .then(function (ok) {\n        subscribed = true;\n        subscription = { consumerTag: ok.consumerTag };\n        self.emit('subscribed');\n      });\n  }\n\n  self.correlator.queueName(options, function (err, uniqueName) {\n    if (err) throw err;\n    self.listenChannel.assertQueue(uniqueName, self.queueOptions)\n      .then(function (qok) {\n        return self.listenChannel.bindQueue(uniqueName, self.exchangeName, self.routingKey || self.queueName);\n      }).then(function () {\n        if (self.ack) {\n          self.log('asserting error queue ' + self.errorQueueName);\n          var errorQueueOptions = extend(self.queueOptions, {\n            autoDelete: options.autoDeleteErrorQueue || false\n          });\n          self.listenChannel.assertQueue(self.errorQueueName, errorQueueOptions)\n          .then(function (_qok) {\n            _subscribe(uniqueName);\n          });\n        } else {\n          _subscribe(uniqueName);\n        }\n      });\n  });\n\n  return {\n    unsubscribe: _unsubscribe\n  };\n};\n\nmodule.exports = PubSubQueue;\n","/home/travis/build/npmtest/node-npmtest-servicebus/node_modules/servicebus/bus/rabbitmq/queue.js":"var EventEmitter = require('events').EventEmitter;\nvar extend = require('extend');\nvar util = require('util');\n\nfunction Queue (options) {\n  options = options || {};\n  var queueOptions = options.queueOptions || {};\n\n  extend(queueOptions, {\n    autoDelete: options.autoDelete || ! (options.ack || options.acknowledge),\n    contentType: options.contentType || 'application/json',\n    durable: Boolean(options.ack || options.acknowledge),\n    exclusive: options.exclusive || false,\n    persistent: Boolean(options.ack || options.acknowledge || options.persistent)\n  });\n\n  this.ack = (options.ack || options.acknowledge);\n  this.assertQueue = (options.assertQueue === undefined) ? true : options.assertQueue;\n  this.bus = options.bus;\n  this.confirmChannel = options.confirmChannel;\n  this.errorQueueName = options.queueName + '.error';\n  this.formatter = options.formatter;\n  this.initialized = false;\n  this.listening = false;\n  this.listenChannel = options.listenChannel;\n  this.log = options.log;\n  this.maxRetries = options.maxRetries || 3;\n  this.queueName = options.queueName;\n  this.queueOptions = queueOptions;\n  this.rejected = {};\n  this.routingKey = options.routingKey;\n  this.sendChannel = options.sendChannel;\n\n  EventEmitter.call(this);\n\n  this.setMaxListeners(Infinity);\n\n  var self = this;\n\n  this.log('asserting queue %s', this.queueName);\n\n  if ( ! this.assertQueue) {\n    self.initialized = true;\n    self.emit('ready');\n  } else {\n    this.listenChannel.assertQueue(this.queueName, this.queueOptions).then(function (_qok) {\n      if (self.ack) {\n        self.log('asserting error queue %s', self.errorQueueName);\n        var errorQueueOptions = extend(self.queueOptions, {\n          autoDelete: options.autoDeleteErrorQueue || false\n        });\n        self.listenChannel.assertQueue(self.errorQueueName, self.queueOptions)\n        .then(function (_qok) {\n          self.initialized = true;\n          self.emit('ready');\n        });\n      } else {\n        self.initialized = true;\n        self.emit('ready');\n      }\n    }).catch(function (err) {\n      self.log('error connecting to queue %s. error: %s', options.queueName, err.toString());\n      self.emit('error', err);\n    });\n  }\n\n}\n\nutil.inherits(Queue, EventEmitter);\n\nQueue.prototype.listen = function listen (callback, options) {\n  options = options || {};\n  queueOptions = options.queueOptions || {};\n\n  var self = this;\n\n  this.log('listening to queue %j', this.queueName);\n\n  if ( ! this.initialized) {\n    return this.on('ready', listen.bind(this, callback, options));\n  }\n\n  this.listenChannel.consume(this.queueName, function (message) {\n    /*\n        Note from http://www.squaremobius.net/amqp.node/doc/channel_api.html\n        & http://www.rabbitmq.com/consumer-cancel.html:\n\n        If the consumer is cancelled by RabbitMQ, the message callback will be invoked with null.\n      */\n    if (message === null) {\n      return;\n    }\n    message.content = options.formatter.deserialize(message.content);\n    options.queueType = 'queue';\n    self.bus.handleIncoming(self.listenChannel, message, options, function (channel, message, options) {\n      // amqplib intercepts errors and closes connections before bubbling up\n      // to domain error handlers when they occur non-asynchronously within\n      // callback. Therefore, if there is a process domain, we try-catch to\n      // redirect the error, assuming the domain creator's intentions.\n      try {\n        callback(message.content, message);\n      } catch (err) {\n        if (process.domain && process.domain.listeners('error')) {\n          process.domain.emit('error', err);\n        } else {\n          self.emit('error', err);\n        }\n      }\n    });\n  }, { noAck: ! self.ack })\n    .then(function (ok) {\n      self.listening = true;\n      self.subscription = { consumerTag: ok.consumerTag };\n      self.emit('listening');\n    });\n\n};\n\nQueue.prototype.destroy = function destroy (options) {\n  options = options || {};\n  var em = new EventEmitter();\n  this.log('deleting queue %s', this.queueName);\n  this.listenChannel.deleteQueue(this.queueName)\n    .then(function (ok) {\n      em.emit('success');\n    });\n  if (this.errorQueueName && this.ack) {\n    this.listenChannel.deleteQueue(this.errorQueueName, { ifEmpty: true });\n  }\n  return em;\n};\n\nQueue.prototype.unlisten = function unlisten () {\n  var em = new EventEmitter();\n  var self = this;\n\n  if (this.listening) {\n    this.listenChannel.cancel(this.subscription.consumerTag)\n      .then(function (err, ok) {\n      delete self.subscription;\n      self.listening = false;\n      self.bus.emit('unlistened', self);\n      em.emit('success');\n    });\n  } else {\n    this.on('listening', unlisten.bind(this));\n  }\n\n  return em;\n};\n\nQueue.prototype.send = function send (event, options, cb) {\n  options = options || {};\n  var self = this;\n\n  if ( ! this.initialized) {\n    return this.on('ready', send.bind(this, event, options, cb));\n  }\n\n  options.contentType = options.contentType || this.contentType;\n  options.persistent = Boolean(options.ack || options.acknowledge || options.persistent || self.ack);\n\n  var channel = cb ? this.confirmChannel : this.sendChannel;\n\n  channel.sendToQueue(this.routingKey || this.queueName, new Buffer(options.formatter.serialize(event)), options, cb);\n\n};\n\nmodule.exports = Queue;\n"}